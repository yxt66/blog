{"meta":{"title":"Taoblog","subtitle":"","description":"test description","author":"Yao Tao","url":"https://yxt66.github.io/blog","root":"/blog/"},"pages":[{"title":"","date":"2023-08-03T09:45:08.449Z","updated":"2023-08-03T09:45:08.449Z","comments":true,"path":"about/index.html","permalink":"https://yxt66.github.io/blog/about/index.html","excerpt":"","text":"有什么想对我说的呢？"},{"title":"All Category","date":"2023-08-03T09:45:08.449Z","updated":"2023-08-03T09:45:08.449Z","comments":true,"path":"categories/index.html","permalink":"https://yxt66.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"All Tag","date":"2023-08-03T09:45:08.449Z","updated":"2023-08-03T09:45:08.449Z","comments":true,"path":"tags/index.html","permalink":"https://yxt66.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"winRAR去广告","slug":"13winRAR去广告 ","date":"2023-07-21T00:00:00.000Z","updated":"2023-08-03T09:45:08.449Z","comments":true,"path":"2023/07/21/13winRAR去广告 /","link":"","permalink":"https://yxt66.github.io/blog/2023/07/21/13winRAR%E5%8E%BB%E5%B9%BF%E5%91%8A%20/","excerpt":"winRAR去广告","text":"winRAR去广告 一、注册并去除弹窗广告（**亲测有效**）​ WinRAR简体中文的个人免费版安装后会有“评估版本”的标记，而且每次启动时会有代理商的弹窗广告。 1、访问 WinRAR 中文版官网，选择对应版本，安装时记住安装目录（选择英文或者繁体版，本人亲测简体版无效）12官网：https://www.rarlab.com/download.htm坑：注意是官网地址，而不是国内代理的地址（winrar.com.cn） 2、新建一个记事本，将下面的注册码复制到记事本内，保存，并将文件名和后缀修改为 “rarreg.key”。1234567891011RAR registration dataSeVeNUnlimited Company LicenseUID=000de082d4cb7aeb1c4f64122122501c4f740157f1ebdb43aacbe102d6a9507d77b7db656654d11f6a4329451f160460fce6cb5ffde62890079861be576387177131ced835ed65cc743d9777f2ea71a8e32c7e593cf66794343565b41bcf56929486b8bcdac33d50ecf7739960a6da6b4e02abc1046a1de3f23f2ffcb196a8beab698d4c570b1d516ca6da41630a72921ffb4823a51dc1a276e552c654592b04407bd6d33ceb003b9460394badc42308815c9a3831d54b208e11c254d3d71f18a3122935273400 3、制作好的 rarreg.key 文件复制到 WinRAR 安装目录，默认安装目录为 C:\\Program Files\\WinRAR4、完成。打开 WinRAR，“评估版本”标记已消失。5、参考注册码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869注册码一RAR registration dataAlexander AymanovSingle PC usage licenseUID=dc1d9fdb26f9be064d8364122122504d83d04ee243231738b88600fb267f1d3b9632421295d1048b98780395138be06035c6ab9048e2c5c62f0238f183d28519aa87488bf38f5b634cf28190bdf438ac593b1857cdb55a7fcb0eb0c3e4c2736090b3dfa45384e08e9de05c58609e0915bfdc561003a6755c95e82155892c0f36e7ff4b3d62f55230e8ad51b6756d092d0b89e5c480d3449cc0c7d9ab1d3d4abb32baf07ebabe0e145e608494e628198aaef1e665f9d63f719cb57ef19f3443f31a830478060233注册码二RAR registration datayaokai.comUnlimited Company LicenseUID=636da5a1e3718a4597b9641221225097b94b94094a6548ed8365940161a87853d63b09c6ff0b86c572d75fb683db5960fce6cb5ffde62890079861be576387177131ced835ed65cc743d9777f2ea71a8e32c7e593cf66794343565b41bcf56929486b8bcdac33d50ecf77399608cfb51a0f9e15e798c57fc8a5e5c3fc69a04ae7d4ec41408c506ff1c90962e165207a4e945d426eae53d8849d222b3b26997e5e18b4526596c75d682603e011364c589ec5fcea9fa5b796e3fa7437cd080392e5d791757768079注册码三RAR registration dataDatabase Administrators5 PC usage licenseUID=54d582e921e445f1bfe86412212250bfe8e73e20bdb947f60ef0da9624150bcf8668412c6884affda559742bbb686d6071302587655a7ba28d516e17834b761647cd79a293eb4c0e4fbf5e9f967e6ed5b28a02418d0ab2549fc4da19e4644f2345190bf26ff7bcd0c819f12560b57cf28adc164a00c63174fcbb69509912e7c7c4793779b941901c6c793b7319cc395ee08bddb923fa08fc20019b59d0b246e0ac325d2e5854d4f97a602fc0a4357b8f857cfb717545410ecad088fb28a2a3cf0dff2102863273注册码四RAR registration dataPROMSTROI GROUP15 PC usage licenseUID=42079a849eb3990521f3641221225021f37c3fecc934136f31d889c3ca46ffcfd8441d3d589157709ba0f6ded3a528605030bb9d68eae7df5fedcd1c12e96626705f33dd41af323a0652075c3cb429f7fc3974f55d1b60e9293e82ed467e6e4f126e19cccccf98c3b9f98c4660341d700d11a5c1aa52be9caf70ca9cee8199c54758f64acc9c27d3968d5e69ecb901b91d538d079f9f1fd1a81d656627d962bf547c38ebbda774df21605c33eccb9c18530ee0d147058f8b282a9ccfc31322fafcbb4251940582注册码五RAR registration dataCarol ThompsonSingle PC usage licenseUID=b8bc6fb0a8094b9eeb296412212250eb294bd5b605e535f7334b6e2e56a9e405a044f60225c843a161a156aa01684c6035c6ab9048e2c5c62f0238f183d28519aa87488bf38f5b634cf28190bdf438ac593b1857cdb55a7fcb0eb0c3e4c2736090b3dfa45384e08e9de05c5860ae8049eaa9443b44f9faac06b7ced5f95ab06b40a99e850616dc92fc5301fe63c674ea553971fefd9e10f300d2a515c74b02f673b7fe5a89fa92f51260a5af78a306093f5763d6acc779488f5d42e9b044836a837c0424153795 二、利用工具去除广告（来自网上，本人未使用）​ 此方法在更新 WinRAR 之后会失效，需要再执行一次方可生效。 1、下载免费的编译和反编译工具 Resource Hacker。安装后打开。1、下载免费的编译和反编译工具 Resource Hacker。安装后打开。1工具官网下载：http://www.angusj.com/resourcehacker/ 2、点击 “File” “Open”，找到 WinRAR 的安装目录（默认安装目录为 C:\\Program Files\\WinRAR），选择 WinRAR.exe，打开。 3、在左侧栏中依次选择 “String Table” “80 : 2052”，删除 1277 行引号内的内容，用空格代替。 4、依次点击下图位置的“运行”“保存”按钮，进行编译和保存。 5、关闭 Resource Hacker，运行 WinRAR，发现弹窗广告彻底消失了！","categories":[{"name":"sofeware","slug":"sofeware","permalink":"https://yxt66.github.io/blog/categories/sofeware/"}],"tags":[{"name":"winRAR去广告","slug":"winRAR去广告","permalink":"https://yxt66.github.io/blog/tags/winRAR%E5%8E%BB%E5%B9%BF%E5%91%8A/"}]},{"title":"异步编程Promise、async、await","slug":"12异步编程Promise，async，await","date":"2022-11-26T00:00:00.000Z","updated":"2023-08-03T09:45:08.449Z","comments":true,"path":"2022/11/26/12异步编程Promise，async，await/","link":"","permalink":"https://yxt66.github.io/blog/2022/11/26/12%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8BPromise%EF%BC%8Casync%EF%BC%8Cawait/","excerpt":"异步编程Promise、async、await","text":"异步编程Promise、async、await 1.Promise三种状态 pending fulfilled rejected 2.如何改变promise的状态 可以调用resolve()、reject()方法和抛出异常。状态一旦生成，不会改变。 3.特点（1）不执行resolve或者reject 就一直是pending状态，pending不会触发then和catch （2）Promise.resolve（）返回的状态取决于括号中的状态；Promise.reject（）返回的是rejected状态的Promise 4.一个 promise 指定多个成功&#x2F;失败回调函数, 都会调用吗? 当promise改变为对应状态时会调用。 5.改变 promise 状态和指定回调函数谁先谁后? 都有可能，正常情况是先执行回调再改变状态，但也可以先改状态再指定回调。 如果先改状态再指定回调 延长时间调用then（） 在执行器中之间调用resolve()&#x2F;reject() 6.什么时候才能得到数据 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据。 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 8.promise.then()返回的新 promise 的结果状态由什么决定?(1) 简单表达: 由 then()指定的回调函数执行的结果v =&gt; &#123;&#125;或e=&gt;&#123;&#125;决定 ,默认为pending状态。 注意：Promise.resolve()和async默认状态为fulfilled (2) 详细表达: ​ ① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常 ​ ② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值 ​ ③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果 9.promise 异常传透?(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调。 (2) 前面任何操作出了异常, 都会传到最后失败的回调中处理 10.中断 promise 链?办法: 在回调函数中返回一个 pendding 状态的 promise 对象 12345678910111213141516171819202122//1. 打印结果：1 p(fulfilled) let p = Promise.reject().catch(e =&gt; &#123; &#125;) p.then(()=&gt;&#123; console.log(1) &#125;) p.catch(()=&gt; &#123; console.log(2) &#125;) setTimeout(()=&gt;&#123; console.log(p); &#125;)//2.打印结果： 1 2 3 Promise.resolve().then(()=&gt;&#123; console.log(1) throw new Error(&#x27;err&#x27;) &#125;).catch(()=&gt;&#123; console.log(2) &#125;).then(()=&gt;&#123; console.log(3) &#125;) 11.Promise源码实现（Es5)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175function Promise(exector) &#123; //1.基础模板 //2.当同步调用resolve,reject,throw影响Promise状态控制执行then返回结果的状态。 //eg: 同步执行let p = new Promise((resolve,reject) =&gt; &#123; resolve(&#x27;ok&#x27;)&#125;); // const res = p.then() 控制res的状态 //3.当异步影响Promise的改变，回调执行then中的函数 //eg: let p = new Promise((resolve,reject) =&gt; &#123; setTimeout(...resolve(&#x27;ok&#x27;))&#125;); //4.v=&gt;&#123;&#125;(onResolve) or e =&gt; &#123;&#125;(onReject)未定义 抛绣球实现异常穿透和值传递 //5.异步执行 this.PromiseStatus = &#x27;pending&#x27; this.PromiseValue = undefined this.callbacks = [] const _this = this function resolve(data) &#123; if (_this.PromiseStatus !== &#x27;pending&#x27;) return _this.PromiseStatus = &#x27;fulfilled&#x27; _this.PromiseValue = data //当状态改变调用then中的函数 setTimeout(() =&gt; &#123; _this.callbacks.forEach(item =&gt; &#123; item.onResolve() &#125;) &#125;) &#125; function reject(data) &#123; if (_this.PromiseStatus !== &#x27;pending&#x27;) return _this.PromiseStatus = &#x27;rejected&#x27; _this.PromiseValue = data //5. setTimeout(() =&gt; &#123; _this.callbacks.forEach(item =&gt; &#123; item.onReject() &#125;) &#125;) &#125; try &#123; exector(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125;//then方法Promise.prototype.then = function (onResolve, onReject) &#123; const _this = this return new Promise((resolve, reject) =&gt; &#123; //4.抛绣球 //值传递 if (typeof onResolve !== &#x27;function&#x27;) &#123; onResolve = value =&gt; value &#125; //异常穿透 if (typeof onReject !== &#x27;function&#x27;) &#123; onReject = e =&gt; &#123; throw e &#125; &#125; //2. //封装函数，避免冗余 function callback(type) &#123; try &#123; let result = type(_this.PromiseValue) if (result instanceof Promise) &#123; result.then(v =&gt; &#123; resolve(v) &#125;, e =&gt; &#123; reject(e) &#125;) &#125; else &#123; resolve(result) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125; if (this.PromiseStatus === &#x27;fulfilled&#x27;) &#123; //5. setTimeout(() =&gt; &#123; callback(onResolve) &#125;) &#125; if (this.PromiseStatus === &#x27;rejected&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onReject) &#125;) &#125; //3. if (this.PromiseStatus === &#x27;pending&#x27;) &#123; //保存then中的函数 this.callbacks.push(&#123; //细节地方：then式调用 onResolve() &#123; callback(onResolve) &#125;, // onResolve ,onReject 这种写法不会改变res的状态一直是pending就无法链式调用 onReject() &#123; callback(onReject) &#125; &#125;) &#125; &#125;)&#125;//catch方法Promise.prototype.catch = function (onReject) &#123; return this.then(undefined, onReject)&#125;//Promise.resolve()Promise.resolve = function (value) &#123; return new Promise((resolve, reject) =&gt; &#123; if (value instanceof Promise) &#123; value.then(v =&gt; &#123; resolve(v) &#125;, e =&gt; &#123; reject(e) &#125;) &#125; else &#123; resolve(value) &#125; &#125;)&#125;//Promise.reject()返回状态永远是rejected状态Promise.reject = function (err) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(err) &#125;)&#125;//Promise.all() 参数可以全是promise对象Promise.all = function (promises) &#123; //1.计数器 空数组 //2.遍历每个Promise.then,不能用push let count = 0 let length = promises.length let resultArr = new Array(length) return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; length; i++) &#123; promises[i].then(v =&gt; &#123; count++ resultArr[i] = v if (count === length) resolve(resultArr) &#125;, e =&gt; &#123; reject(e) &#125;) &#125; &#125;)&#125;//Promise.race() 参数可以全是promise对象Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; // if(!promises[i] instanceof Promise) &#123; // 转为Promise对象 // &#125; promises[i].then(v =&gt; &#123; resolve(v) &#125;, e =&gt; &#123; reject(e) &#125;) &#125; &#125;)&#125; 12.Promise源码实现（Es6)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// const PromiseStatus = &#x27;pending&#x27;class Promise &#123; constructor(exector) &#123; this.PromiseStatus = &#x27;pending&#x27; this.PromiseValue = undefined this.callbacks = [] //resolve const resolve = data =&gt; &#123; if (this.PromiseStatus !== &#x27;pending&#x27;) return this.PromiseStatus = &#x27;fulfilled&#x27; this.PromiseValue = data //当状态改变调用then中的函数 setTimeout(() =&gt; &#123; this.callbacks.forEach(item =&gt; &#123; item.onResolve() &#125;) &#125;) &#125; //reject const reject = data =&gt; &#123; if (this.PromiseStatus !== &#x27;pending&#x27;) return this.PromiseStatus = &#x27;rejected&#x27; this.PromiseValue = data setTimeout(() =&gt; &#123; this.callbacks.forEach(item =&gt; &#123; item.onReject() &#125;) &#125;) &#125; try &#123; exector(resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125; then(onResolve, onReject) &#123; return new Promise((resolve, reject) =&gt; &#123; //值传递 if (typeof onResolve !== &#x27;function&#x27;) &#123; onResolve = value =&gt; value &#125; //异常穿透 if (typeof onReject !== &#x27;function&#x27;) &#123; onReject = e =&gt; &#123; throw e &#125; &#125; //封装函数，避免冗余 const callback = type =&gt; &#123; try &#123; let result = type(this.PromiseValue) if (result instanceof Promise) &#123; result.then(v =&gt; &#123; resolve(v) &#125;, e =&gt; &#123; reject(e) &#125;) &#125; else &#123; resolve(result) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125; if (this.PromiseStatus === &#x27;fulfilled&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onResolve) &#125;) &#125; if (this.PromiseStatus === &#x27;rejected&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onReject) &#125;) &#125; if (this.PromiseStatus === &#x27;pending&#x27;) &#123; this.callbacks.push(&#123; onResolve() &#123; callback(onResolve) &#125;, onReject() &#123; callback(onReject) &#125; &#125;) &#125; &#125;) &#125; catch(onReject) &#123; return this.then(undefined, onReject) &#125; //静态成员 static resolve(value) &#123; return new Promise((resolve, reject) =&gt; &#123; if (value instanceof Promise) &#123; value.then(v =&gt; &#123; resolve(v) &#125;, e =&gt; &#123; reject(e) &#125;) &#125; else &#123; resolve(value) &#125; &#125;) &#125; static reject(err) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(err) &#125;) &#125; static all(promises) &#123; let count = 0 let length = promises.length let resultArr = new Array(length) return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; length; i++) &#123; promises[i].then(v =&gt; &#123; count++ resultArr[i] = v if (count === length) resolve(resultArr) &#125;, e =&gt; &#123; reject(e) &#125;) &#125; &#125;) &#125; static race(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; // if(!promises[i] instanceof Promise) &#123; // 转为Promise对象 // &#125; promises[i].then(v =&gt; &#123; resolve(v) &#125;, e =&gt; &#123; reject(e) &#125;) &#125; &#125;) &#125;&#125; 13.async、await async 函数 只能修饰异步函数，函数的返回值为 promise 对象 promise 对象的结果由 async 函数执行的返回值决定（同promise.resolve()） await await 右侧的表达式一般为 promise 对象, 但也可以是其它的值 如果表达式是 promise 对象, await 返回的是 promise 成功的值 如果表达式是其它值, 直接将此值作为 await 的返回值 await 必须写在 async 函数中, 但 async 函数中可以没有 await 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理，后面的代码将不会执行 14.综合习题","categories":[{"name":"Js","slug":"Js","permalink":"https://yxt66.github.io/blog/categories/Js/"}],"tags":[{"name":"异步","slug":"异步","permalink":"https://yxt66.github.io/blog/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"Cookie、Token","slug":"11token、cookie","date":"2022-11-18T00:00:00.000Z","updated":"2023-08-03T09:45:08.449Z","comments":true,"path":"2022/11/18/11token、cookie/","link":"","permalink":"https://yxt66.github.io/blog/2022/11/18/11token%E3%80%81cookie/","excerpt":"Cookie、Token","text":"Cookie、Token Cookie 作用：http连接是无状态的，客户端与服务器每次都要验证身份，耗费性能。 cookie是配合session认证机制，客户端在第一次登陆验证通过后服务器会开辟内存创建session保存客户端的信息，然后给客户端发送一个cookie，客户端拿到cookie后保存起来，后面的请求都会自动带上cookie，服务端验证该cookie的有效性。 cookie不能跨域访问，大小最多是4kb。 Token 上面所说每次客户端验证通过后，服务器要创建新的session保留客户端的信息，这无疑增加了服务器的压力。当用户量增大的时候，假如服务器要把这些session分摊到其他服务器上减少压力，而cookie的也不能跨域访问。 token配合jwt认证机制，当客户验证通过后，给客户端发送token，客户拿到token后可以保存在cookie中，也可以保存在localStorage、sessionStorage等，下次的请求客户端带上token，服务器直接验证token有效性。 token支持跨域访问，需要客户端自己存储，灵活性高。 区别：cookie不能跨域访问，大小最多是4kb。token没有内存限制，需要客户端自己存储，可以存储在cookie中，支持跨域访问。 相同点：都可以进行身份认证。","categories":[{"name":"Js","slug":"Js","permalink":"https://yxt66.github.io/blog/categories/Js/"}],"tags":[{"name":"Cookie、Token","slug":"Cookie、Token","permalink":"https://yxt66.github.io/blog/tags/Cookie%E3%80%81Token/"}]},{"title":"Vue3","slug":"10vue3","date":"2022-11-17T00:00:00.000Z","updated":"2023-08-03T09:45:08.449Z","comments":true,"path":"2022/11/17/10vue3/","link":"","permalink":"https://yxt66.github.io/blog/2022/11/17/10vue3/","excerpt":"Vue3","text":"Vue3 一.vite二. Vue3新特性2.1 CompositionAPI（组合API）1 setup() setup 在beforeCreate之前会执行一次，this是undefined 参数setup（props,context） props：是响应式的。 注意：如果结构了props对象，解构出来的变量会丢失响应式。 推荐使用props.xxx 123456export default &#123; props:[&#x27;title&#x27;] setup(props) &#123; console.log(props.title) &#125;&#125; context：上下文对象。非响应式的。放心解构 attrs：包含组件没有在props中声明的属性。 slots： 收到的插槽内容。 emit：自定义事件的函数。 123456789101112131415export default &#123; setup(props, context) &#123; // 透传 Attributes（非响应式的对象，等价于 $attrs） console.log(context.attrs) // 插槽（非响应式的对象，等价于 $slots） console.log(context.slots) // 触发事件（函数，等价于 $emit） console.log(context.emit) // 暴露公共属性（函数） console.log(context.expose) &#125;&#125; 参考链接：https://cn.vuejs.org/api/composition-api-setup.html#basic-usage 2 ref() 作用： 定义一个响应式的数据 语法： const xxx = ref(initValue) initValue可以是基本类型、对象类型（包含数组）。 基本类型的数据：通过Object.defineProperty() 对象类型的数据：使用了reactive函数 创建了一个响应式数据的引用对象（reference对象的实现类实例，简称ref对象） js中操作数据xxx.value，模板中读取数据不需要.value 直接&lt;h1&gt;&#123;&#123;xxx&#125;&#125;&lt;/h1&gt; 3. reactive() 作用：定义对象类型（包含数组）的响应式数据（深层次的） 语法： const xxx = reactive(源对象)返回一个Proxy代理对象的实例，简称Proxy对象 基于Proxy和Reflect 均不需要.value操作数据 4.watch(监视ref和reactive) 参数：function（带有返回值）, ref, reactive object, or array（由前三种类型组成的数组） 坑： 监视reactive定义的响应式数据时：oldValue无法正确获取、默认强制开启了深度监视（deep配置失效）。 监视reactive定义的响应式数据中某个属性时：deep配置有效。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//情况一：监视ref定义的响应式数据let sum = ref(0)let msg = ref(&#x27;hello&#x27;)watch(sum,(newVal,oldVal)=&gt;&#123; console.log(&#x27;sum变化了&#x27;,newVal,oldVal)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newVal,oldVal)=&gt;&#123; console.log(&#x27;sum或msg变化了&#x27;,newVal,oldVal) //newVal 和 oldVal都是数组形式输出&#125;) //情况三：监视reactive定义的响应式数据//注意：//1.若watch监视的是reactive定义的响应式数据，则无法正确获得 oldValue！！//2.默认强制开启了深度监视（deep配置失效）。 setup()&#123; const person = reactive(&#123; name: &#x27;tao&#x27;, age: 18, school: &#123; name: &#x27;xxx&#x27;, &#125; &#125;) watch(person,(newVal,oldVal) =&gt; &#123; console.log(newVal,oldVal) &#125;,&#123;immediate:true,deep:false&#125;) &#125;, //情况四：监视reactive定义的响应式数据中的某个属性 （deep配置有效）。 watch(()=&gt; person.school.name,(newVal,oldVal) =&gt; &#123; console.log(newVal,oldVal) &#125;,&#123;immediate:true,deep:true&#125;)//情况五：监视reactive定义的响应式数据中的某些属性 watch([ () =&gt; person.school.name, () =&gt; person.name],(newVal,oldVal) =&gt; &#123; console.log(newVal,oldVal) &#125;,&#123;immediate:true,deep:true&#125;)//情况六： 不能获取到旧的值watch(person.school,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) 参考：https://cn.vuejs.org/api/reactivity-core.html#watch 5.watchEffect 监视的属性，加逻辑代码（一检测到该属性的变化，函数体内的代码就会执行一遍） 注重的是过程。 123456//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123; const x1 = sum.value const x2 = person.age console.log(&#x27;watchEffect配置的回调执行了&#x27;)&#125;) 参考：https://cn.vuejs.org/api/reactivity-core.html#watcheffect 6.computed 参数：get函数 or get、set函数 写法：简写和完整 简写：接受一个 getter 函数，返回一个只读的响应式 ref 对象。该 ref 通过 .value 暴露 getter 函数的返回值 123456const count = ref(1)const plusOne = computed(() =&gt; count.value + 1)console.log(plusOne.value) // 2plusOne.value++ // 错误 完整：接收get 和 set 函数的对象来创建一个可写的 ref 对象 1234567891011121314151617181920import &#123;computed&#125; from &#x27;vue&#x27;setup()&#123; ... //计算属性——简写 let fullName = computed(()=&gt;&#123; return person.firstName + &#x27;-&#x27; + person.lastName &#125;) //计算属性——完整 let fullName = computed(&#123; get()&#123; return person.firstName + &#x27;-&#x27; + person.lastName &#125;, set(value)&#123; const nameArr = value.split(&#x27;-&#x27;) person.firstName = nameArr[0] person.lastName = nameArr[1] &#125; &#125;)&#125; 7.生命周期 8、hook函数 类似Mixin 9、toRef 作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。 语法：const name = toRef(person,&#39;name&#39;) 应用: 要将响应式对象中的某个属性单独提供给外部使用时。 扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person) 12345678910const person = reactive(&#123; name: &#x27;tao&#x27;, age: 18, school: &#123; name: &#x27;xxx&#x27;, msg: &#123; count: 100 &#125; &#125; &#125;) 通过toRef（）连接person 实现同步 123456return &#123; person, name:toRef(person,&#x27;name&#x27;), //name与person实现同步 age:toRef(person,&#x27;age&#x27;), count:toRef(person.school.msg,&#x27;count&#x27;), &#125; 三、其它 Composition API1.shallowReactive 与 shallowRef shallowReactive：只处理对象最外层属性的响应式（浅响应式）。 shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。 什么时候使用? 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。 2.readonly 与 shallowReadonly readonly: 让一个响应式数据变为只读的（深只读）。 shallowReadonly：让一个响应式数据变为只读的（浅只读）。 应用场景: 不希望数据被修改时。 3.toRaw 与 markRaw toRaw： 作用：将一个由reactive生成的响应式对象转为普通对象。 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。 markRaw： 作用：标记一个对象，使其永远不会再成为响应式对象。 应用场景: 有些值不应被设置为响应式的，例如复杂的第三方类库等。 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。 4.customRef 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。 实现防抖效果： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt; &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; import &#123;ref,customRef&#125; from &#x27;vue&#x27; export default &#123; name:&#x27;Demo&#x27;, setup()&#123; // let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref //自定义一个myRef function myRef(value,delay)&#123; let timer //通过customRef去实现自定义 return customRef((track,trigger)=&gt;&#123; return&#123; get()&#123; track() //告诉Vue这个value值是需要被“追踪”的 return value &#125;, set(newValue)&#123; clearTimeout(timer) timer = setTimeout(()=&gt;&#123; value = newValue trigger() //告诉Vue去更新界面 &#125;,delay) &#125; &#125; &#125;) &#125; let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref return &#123; keyword &#125; &#125; &#125;&lt;/script&gt; 5.provide 与 inject 作用：实现祖与后代组件间通信 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据 具体写法： 祖组件中： 123456setup()&#123; ...... let car = reactive(&#123;name:&#x27;奔驰&#x27;,price:&#x27;40万&#x27;&#125;) provide(&#x27;car&#x27;,car) ......&#125; 后代组件中： 123456setup(props,context)&#123; ...... const car = inject(&#x27;car&#x27;) return &#123;car&#125; ......&#125; 6.响应式数据的判断 isRef: 检查一个值是否为一个 ref 对象 isReactive: 检查一个对象是否是由 reactive 创建的响应式代理 isReadonly: 检查一个对象是否是由 readonly 创建的只读代理 isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理 四、Composition API 的优势1.Options API 存在的问题使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。 2.Composition API 的优势我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。 五、新的组件1.Fragment 在Vue2中: 组件必须有一个根标签 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中 好处: 减少标签层级, 减小内存占用 2.Teleport 什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。 12345678&lt;teleport to=&quot;移动位置&quot;&gt; &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;h3&gt;我是一个弹窗&lt;/h3&gt; &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/teleport&gt; 3.Suspense 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 12import &#123;defineAsyncComponent&#125; from &#x27;vue&#x27;const Child = defineAsyncComponent(()=&gt;import(&#x27;./components/Child.vue&#x27;)) 使用Suspense包裹组件，并配置好default 与 fallback 12345678910111213&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h3&gt;我是App组件&lt;/h3&gt; &lt;Suspense&gt; &lt;template v-slot:default&gt; &lt;Child/&gt; &lt;/template&gt; &lt;template v-slot:fallback&gt; &lt;h3&gt;加载中.....&lt;/h3&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;/div&gt;&lt;/template&gt; 六、其他1.全局API的转移 Vue 2.x 有许多全局 API 和配置。 例如：注册全局组件、注册全局指令等。 123456789101112//注册全局组件Vue.component(&#x27;MyButton&#x27;, &#123; data: () =&gt; (&#123; count: 0 &#125;), template: &#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;&#125;)//注册全局指令Vue.directive(&#x27;focus&#x27;, &#123; inserted: el =&gt; el.focus()&#125; Vue3.0中对这些API做出了调整： 将全局的API，即：Vue.xxx调整到应用实例（app）上 2.x 全局 API（Vue） 3.x 实例 API (app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties 2.其他改变 data选项应始终被声明为一个函数。 过度类名的更改： Vue2.x写法 12345678.v-enter,.v-leave-to &#123; opacity: 0;&#125;.v-leave,.v-enter-to &#123; opacity: 1;&#125; Vue3.x写法 123456789.v-enter-from,.v-leave-to &#123; opacity: 0;&#125;.v-leave-from,.v-enter-to &#123; opacity: 1;&#125; 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes 移除v-on.native修饰符 父组件中绑定事件 1234&lt;my-component v-on:close=&quot;handleComponentEvent&quot; v-on:click=&quot;handleNativeClickEvent&quot;/&gt; 子组件中声明自定义事件 12345&lt;script&gt; export default &#123; emits: [&#x27;close&#x27;] &#125;&lt;/script&gt; 移除过滤器（filter） 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。 ……","categories":[{"name":"Vue","slug":"Vue","permalink":"https://yxt66.github.io/blog/categories/Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://yxt66.github.io/blog/tags/Vue3/"}]},{"title":"Vue2、3响应式数据原理","slug":"09vue2、3响应式数据原理","date":"2022-11-16T00:00:00.000Z","updated":"2023-08-03T09:45:08.445Z","comments":true,"path":"2022/11/16/09vue2、3响应式数据原理/","link":"","permalink":"https://yxt66.github.io/blog/2022/11/16/09vue2%E3%80%813%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/","excerpt":"Vue2、3响应式数据原理","text":"Vue2、3响应式数据原理 1.Vue2响应式数据简单实现原理： 通过Object.defineProperty()劫持各个属性的get、set方法 缺点： 1.不能监听到对象上属性的新增和删除 解决办法：1.vm.$set(target,prop,value) ​ 2.Vue.set(target,prop,value) eg.Vue.set(obj,&#39;sex&#39;,&#39;男&#39;) 2.不能监听数组的变化(eg. arr[index] = xxx arr.length 仍无法实现响应式) 解决办法: 1.Vue通过重写数组原型上的办法实现响应式数据 注意：仅限数组的push/pop/shift/unshift/splice/sort/reverse七个方法 123456789101112131415161718//Vue2响应式数据简单实现原理： let obj = &#123; name: &#x27;tao&#x27;, age: 18 &#125; Object.keys(obj).forEach(item =&gt; &#123; let val = obj[item] Object.defineProperty(obj,item,&#123; get()&#123; console.log(`obj中$&#123;item&#125;属性被获取了,Vue2去更新视图`) return this.val &#125;, set(newVal)&#123; console.log(`obj中$&#123;item&#125;属性被修改了,Vue2去更新视图`) return this.newVal &#125; &#125;) &#125;) 2. Vue3响应式数据简单实现原理: 通过Proxy和Reflect实现响应式，通过劫持源对象返回一个代理对象的实例 12345678910111213141516171819202122// Vue3响应式数据简单实现原理: let handler = &#123; get(target,prop)&#123; console.log(`obj中$&#123;prop&#125;属性被获取了,Vue3去更新视图`) return Reflect.get(target,prop) &#125;, set(target,prop,value)&#123; console.log(`obj中$&#123;prop&#125;属性被修改(包括添加)了,Vue3去更新视图`) return Reflect.set(target,prop,value) &#125; &#125; let p = new Proxy(obj,handler) //handler至少是一个空对象,通过p 实现对obj的操作 // p.name = &#x27;yao&#x27; // expected output: // obj中name属性被修改(包括添加)了,Vue3去更新视图 // obj中name属性被修改了,Vue2去更新视图 obj.name = &#x27;yao&#x27; // expected output: // obj中name属性被修改了,Vue2去更新视图 3.Vue3的ref函数和reactive函数3.1 ref函数 作用： 定义一个响应式的数据 语法： const xxx = ref(initValue) initValue可以是基本类型、对象类型（包含数组）。 基本类型的数据：通过Object.defineProperty() 对象类型的数据：使用了reactive函数 创建了一个响应式数据的引用对象（reference对象的实现类实例，简称ref对象） js中操作数据xxx.value，模板中读取数据不需要.value 直接&lt;h1&gt;&#123;&#123;xxx&#125;&#125;&lt;/&gt; 3.2 reactive函数 作用：定义对象类型（包含数组）的响应式数据（深层次的） 语法： const xxx = reactive(源对象)返回一个Proxy代理对象的实例，简称Proxy对象 基于Proxy和Reflect 均不需要.value操作数据 3.3区别 定义数据： ref可以定义基本数据和对象类型数据，reactive只能定义对象类型数据。 原理：如上 使用：","categories":[{"name":"Vue","slug":"Vue","permalink":"https://yxt66.github.io/blog/categories/Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://yxt66.github.io/blog/tags/Vue3/"}]},{"title":"郑成河 -《Always With Me》","slug":"07《Always With Me》","date":"2022-11-13T00:00:00.000Z","updated":"2023-08-03T09:45:08.445Z","comments":true,"path":"2022/11/13/07《Always With Me》/","link":"","permalink":"https://yxt66.github.io/blog/2022/11/13/07%E3%80%8AAlways%20With%20Me%E3%80%8B/","excerpt":"郑成河 -《Always With Me》","text":"郑成河 -《Always With Me》","categories":[{"name":"Guitar","slug":"Guitar","permalink":"https://yxt66.github.io/blog/categories/Guitar/"}],"tags":[{"name":"《Always With Me》","slug":"《Always-With-Me》","permalink":"https://yxt66.github.io/blog/tags/%E3%80%8AAlways-With-Me%E3%80%8B/"}]},{"title":"Es6 模块化","slug":"05Es6模块化","date":"2022-11-10T00:00:00.000Z","updated":"2023-08-03T09:45:08.445Z","comments":true,"path":"2022/11/10/05Es6模块化/","link":"","permalink":"https://yxt66.github.io/blog/2022/11/10/05Es6%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"Es6模块化","text":"Es6模块化 1.分别暴露123//m1.jsexport let school = &#x27;tao&#x27;export const teach = () =&gt; console.log(&#x27;yao&#x27;) 1234&lt;script type=&quot;module&quot;&gt; import * as m1 from &#x27;/m1.js&#x27; console.log(m1.school)&lt;/script&gt; 2.统一暴露1234567//m2.jslet school = &#x27;&#x27;const teach = () =&gt; export &#123; school, teach&#125; 1234&lt;script type=&quot;module&quot;&gt; import * as m2 from &#x27;/m2.js&#x27; console.log(m2.school)&lt;/script&gt; 3.默认暴露123456//m3.jsexport default &#123; school：‘tao&#x27; teach()&#123; &#125;&#125; 1234&lt;script type=&quot;module&quot;&gt; import * as m3 from &#x27;/m3.js&#x27; console.log(m3.default.school) //default：&#123;school....&#125;&lt;/script&gt; 4.导入方式1234567//1.通用导入方式import * as 别名 from ’‘//2.解构赋值import &#123;&#125; from ’‘import &#123;default as m3&#125; from &#x27;&#x27;//针对默认暴露//3.简便方式 只支持默认暴露import m3 from &#x27;&#x27;","categories":[{"name":"Es6","slug":"Es6","permalink":"https://yxt66.github.io/blog/categories/Es6/"}],"tags":[{"name":"Es6模块化","slug":"Es6模块化","permalink":"https://yxt66.github.io/blog/tags/Es6%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"nodejs 安装问题","slug":"04nodejs安装问题","date":"2022-11-09T00:00:00.000Z","updated":"2023-08-03T09:45:08.445Z","comments":true,"path":"2022/11/09/04nodejs安装问题/","link":"","permalink":"https://yxt66.github.io/blog/2022/11/09/04nodejs%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/","excerpt":"nodejs安装","text":"nodejs安装 1.下载地址12//下载地址https://nodejs.org/zh-cn/download/releases/ 2.新建两个文件放node的模块和缓存12345npm config set prefix &quot;D:\\nodesjs\\node_global&quot;npm config set cache &quot;D:\\nodesjs\\node_cache&quot;npm config list //查看是否配置成功 3.将下面路径添加到系统环境变量中1D:\\nodesjs\\node_global//添加到环境变量中 4.配置淘宝镜像和cnpm12npm config set registry https://registry.npm.taobao.org/npm install -g cnpm --registry=https://registry.npm.taobao.org 5.vue-admin-template-master1//我nodejs@18运行模板出现nodejs版本不兼容问题，通过降低nodejs版本到@16后，仍然出现core-js问题，通过安装指定core-js@3版本解决。","categories":[{"name":"Software Install","slug":"Software-Install","permalink":"https://yxt66.github.io/blog/categories/Software-Install/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://yxt66.github.io/blog/tags/nodejs/"}]},{"title":"_config.yml 配置问题","slug":"02blog","date":"2022-11-05T00:00:00.000Z","updated":"2023-08-03T09:45:08.445Z","comments":true,"path":"2022/11/05/02blog/","link":"","permalink":"https://yxt66.github.io/blog/2022/11/05/02blog/","excerpt":"blog配置","text":"blog配置 blog配置问题1._config.yml配置1234567891011deploy: type: 部署类型(git) branch: 分支名(master) repo: 部署路径(git@github.com:name/name.git)//URL此处配置错误将编译后文件路径会出现问题//io后面没有/blog会导致搜索出现问题//If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;url: &quot;https://yxt66.github.io/blog&quot;root: /blog/ 2.安装hexo脚手架1npm i hexo-cl","categories":[{"name":"Software Install","slug":"Software-Install","permalink":"https://yxt66.github.io/blog/categories/Software-Install/"}],"tags":[{"name":"Hexo Config","slug":"Hexo-Config","permalink":"https://yxt66.github.io/blog/tags/Hexo-Config/"}]},{"title":"Welcome Tao's blog","slug":"01code-highlight","date":"2022-11-04T16:43:00.000Z","updated":"2023-08-03T09:45:08.445Z","comments":true,"path":"2022/11/04/01code-highlight/","link":"","permalink":"https://yxt66.github.io/blog/2022/11/04/01code-highlight/","excerpt":"Welcome !","text":"Welcome ! 123456789101112131415&lt;!DOCTYPE html&gt;&lt;title&gt;Title&lt;/title&gt;&lt;style&gt;body &#123;width: 500px;&#125;&lt;/style&gt;&lt;script type=&quot;application/javascript&quot;&gt; funciton $init()&#123; alert(&#x27;Welcome&#x27;) &#125;&lt;/script&gt;&lt;body&gt; &lt;p checked class=&quot;title&quot; id=&#x27;title&#x27;&gt;Title&lt;/p&gt; &lt;!-- here goes the rest of the page --&gt;&lt;/body&gt;","categories":[],"tags":[]}],"categories":[{"name":"sofeware","slug":"sofeware","permalink":"https://yxt66.github.io/blog/categories/sofeware/"},{"name":"Js","slug":"Js","permalink":"https://yxt66.github.io/blog/categories/Js/"},{"name":"Vue","slug":"Vue","permalink":"https://yxt66.github.io/blog/categories/Vue/"},{"name":"Guitar","slug":"Guitar","permalink":"https://yxt66.github.io/blog/categories/Guitar/"},{"name":"Es6","slug":"Es6","permalink":"https://yxt66.github.io/blog/categories/Es6/"},{"name":"Software Install","slug":"Software-Install","permalink":"https://yxt66.github.io/blog/categories/Software-Install/"}],"tags":[{"name":"winRAR去广告","slug":"winRAR去广告","permalink":"https://yxt66.github.io/blog/tags/winRAR%E5%8E%BB%E5%B9%BF%E5%91%8A/"},{"name":"异步","slug":"异步","permalink":"https://yxt66.github.io/blog/tags/%E5%BC%82%E6%AD%A5/"},{"name":"Cookie、Token","slug":"Cookie、Token","permalink":"https://yxt66.github.io/blog/tags/Cookie%E3%80%81Token/"},{"name":"Vue3","slug":"Vue3","permalink":"https://yxt66.github.io/blog/tags/Vue3/"},{"name":"《Always With Me》","slug":"《Always-With-Me》","permalink":"https://yxt66.github.io/blog/tags/%E3%80%8AAlways-With-Me%E3%80%8B/"},{"name":"Es6模块化","slug":"Es6模块化","permalink":"https://yxt66.github.io/blog/tags/Es6%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yxt66.github.io/blog/tags/nodejs/"},{"name":"Hexo Config","slug":"Hexo-Config","permalink":"https://yxt66.github.io/blog/tags/Hexo-Config/"}]}